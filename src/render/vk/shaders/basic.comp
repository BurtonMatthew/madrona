#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_shader_explicit_arithmetic_types : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_control_flow_attributes : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_vote : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference2 : require

#ifdef VALIDATE 
#extension GL_EXT_debug_printf : enable
#endif

// GLSL wants this for uint64_t -> accel struct conversion
#extension GL_EXT_ray_tracing : require

#define ISTHREAD0 (gl_GlobalInvocationID.x == 0 && \
                   gl_GlobalInvocationID.y == 0 && \
                   gl_GlobalInvocationID.z == 0)

#include "shader_common.h"
#include "utils.glsl"

struct Triangle {
    Vertex a;
    Vertex b;
    Vertex c;
};

layout (push_constant, scalar) uniform PushConstant {
    RTPushConstant push_const;
};

layout (set = 0, binding = 0, scalar) readonly buffer Vertices {
    PackedVertex vertexBuffer[];
};

layout (set = 0, binding = 1, scalar) readonly buffer Indices {
    uint32_t indexBuffer[];
};

layout (set = 0, binding = 2, scalar) readonly buffer Meshes {
    Mesh meshBuffer[];
};

layout (set = 0, binding = 3)
    uniform accelerationStructureEXT accelStructs[];

layout (set = 0, binding = 4, scalar) readonly buffer Cameras {
    PackedCamera cameraBuffer[];
};

layout (set = 0, binding = 5, scalar) writeonly buffer RGBOut {
    uint8_t rgbOut[];
};

layout (set = 0, binding = 6, scalar) writeonly buffer DepthOut {
    float depthOut[];
};

Camera unpackCamera(uint32_t cam_idx)
{
    PackedCamera packed = cameraBuffer[cam_idx];

    float aspect = float(RES_X) / float(RES_Y);

    vec4 rot = packed.rotation;
    vec3 view = quatRotate(rot, vec3(0.f, 0.f, 1.f));
    vec3 up = quatRotate(rot, vec3(0.f, 1.f, 0.f));
    vec3 right = quatRotate(rot, vec3(1.f, 0.f, 0.f));

    vec4 pos_fov = packed.posAndTanFOV;

    vec3 origin = pos_fov.xyz;

    float right_scale = aspect * pos_fov.w;
    float up_scale = pos_fov.w;

    return Camera(origin, view, up, right, right_scale, up_scale);
}

Vertex unpackVertex(uint32_t idx)
{
    PackedVertex packed = vertexBuffer[nonuniformEXT(idx)];

    vec4 a = packed.data[0];
    vec4 b = packed.data[1];

    u32vec3 packed_normal_tangent = u32vec3(
        floatBitsToUint(a.w), floatBitsToUint(b.x), floatBitsToUint(b.y));

    vec3 normal;
    vec4 tangent_and_sign;
    decodeNormalTangent(packed_normal_tangent, normal, tangent_and_sign);

    Vertex vert;
    vert.position = vec3(a.x, a.y, a.z);
    vert.normal = normal;
    vert.tangentAndSign = tangent_and_sign;
    vert.uv = vec2(b.z, b.w);

    return vert;
}

u32vec3 fetchTriangleIndices(uint32_t index_offset)
{
    // FIXME: maybe change all this to triangle offset
    return u32vec3(
        indexBuffer[nonuniformEXT(index_offset)],
        indexBuffer[nonuniformEXT(index_offset + 1)],
        indexBuffer[nonuniformEXT(index_offset + 2)]);
}

Triangle fetchTriangle(uint32_t index_offset)
{
    u32vec3 indices = fetchTriangleIndices(index_offset);

    return Triangle(
        unpackVertex(indices.x),
        unpackVertex(indices.y),
        unpackVertex(indices.z));
}

#define INTERPOLATE_ATTR(a, b, c, barys) \
    (a + barys.x * (b - a) + \
     barys.y * (c - a))

vec3 interpolatePosition(vec3 a, vec3 b, vec3 c, vec2 barys)
{
    return INTERPOLATE_ATTR(a, b, c, barys);
}

vec3 interpolateNormal(vec3 a, vec3 b, vec3 c, vec2 barys)
{
    return INTERPOLATE_ATTR(a, b, c, barys);
}

vec4 interpolateCombinedTangent(vec4 a, vec4 b, vec4 c, vec2 barys)
{
    return INTERPOLATE_ATTR(a, b, c, barys);
}

vec2 interpolateUV(vec2 a, vec2 b, vec2 c, vec2 barys)
{
    return INTERPOLATE_ATTR(a, b, c, barys);
}

void computeCameraRay(in Camera camera, in u32vec2 idx,
                      out vec3 ray_origin, out vec3 ray_dir)
{
    vec2 raster = vec2(idx.x, idx.y) + vec2(0.5f);

    vec2 screen = vec2((2.f * raster.x) / RES_X - 1,
                       (2.f * raster.y) / RES_Y - 1);

    vec3 right = camera.right * camera.rightScale;
    vec3 up = camera.up * camera.upScale;

    ray_origin = camera.origin;
    ray_dir = right * screen.x + up * screen.y + camera.view;

    ray_dir = normalize(ray_dir);
}

bool traceShadeRay(rayQueryEXT ray_query, in uint32_t tlas_idx,
                   in vec3 ray_origin, in vec3 ray_dir,
                   uint32_t visibility_mask)
{
    rayQueryInitializeEXT(ray_query, accelStructs[tlas_idx],
        gl_RayFlagsTerminateOnFirstHitEXT |
            gl_RayFlagsCullBackFacingTrianglesEXT,
        visibility_mask, ray_origin, 0.f, ray_dir, LARGE_DISTANCE);

    while (rayQueryProceedEXT(ray_query)) {
        if (rayQueryGetIntersectionTypeEXT(ray_query, false) ==
            gl_RayQueryCandidateIntersectionTriangleEXT) {

            rayQueryConfirmIntersectionEXT(ray_query);
        }
    }

    subgroupBarrier();

    return rayQueryGetIntersectionTypeEXT(ray_query, true) !=
        gl_RayQueryCommittedIntersectionNoneEXT;
}

bool traceShadowRay(in uint32_t tlas_idx, in vec3 ray_origin,
                    in vec3 ray_dir, in float ray_len,
                    in uint32_t visibility_mask)
{
    rayQueryEXT ray_query;
    rayQueryInitializeEXT(ray_query, accelStructs[tlas_idx],
        gl_RayFlagsTerminateOnFirstHitEXT, visibility_mask,
        ray_origin, 0.f, ray_dir, ray_len);

    while (rayQueryProceedEXT(ray_query)) {
        if (rayQueryGetIntersectionTypeEXT(ray_query, false) ==
            gl_RayQueryCandidateIntersectionTriangleEXT) {

            rayQueryConfirmIntersectionEXT(ray_query);
        }
    }

    subgroupBarrier();

    return rayQueryGetIntersectionTypeEXT(ray_query, true) !=
        gl_RayQueryCommittedIntersectionNoneEXT;
}

void setOutput(uint32_t rgb_offset, uint32_t depth_offset,
               vec3 rgb, float depth)
{
    rgbOut[nonuniformEXT(rgb_offset)] =
        uint8_t(round(255.f * min(rgb.x, 1.f)));
    rgbOut[nonuniformEXT(rgb_offset + 1)] =
        uint8_t(round(255.f * min(rgb.y, 1.f)));
    rgbOut[nonuniformEXT(rgb_offset + 2)] =
        uint8_t(round(255.f * min(rgb.z, 1.f)));
    rgbOut[nonuniformEXT(rgb_offset + 3)] = uint8_t(255);

    depthOut[nonuniformEXT(depth_offset)] = depth;
}

void getHitParams(in rayQueryEXT ray_query, out vec2 barys,
                  out uint32_t tri_idx, out uint32_t material_offset,
                  out uint32_t geo_idx, out uint32_t mesh_offset,
                  out mat4x3 o2w, out mat4x3 w2o)
{
    barys = rayQueryGetIntersectionBarycentricsEXT(ray_query, true);

    tri_idx =
        uint32_t(rayQueryGetIntersectionPrimitiveIndexEXT(ray_query, true));

    material_offset = uint32_t(
        rayQueryGetIntersectionInstanceCustomIndexEXT(ray_query, true));

    geo_idx = 
        uint32_t(rayQueryGetIntersectionGeometryIndexEXT(ray_query, true));

    mesh_offset = uint32_t(
        rayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetEXT(
            ray_query, true));

    o2w = rayQueryGetIntersectionObjectToWorldEXT(ray_query, true);
    w2o = rayQueryGetIntersectionWorldToObjectEXT(ray_query, true);
}

// Entry point

layout (local_size_x = LOCAL_WORKGROUP_X,
        local_size_y = LOCAL_WORKGROUP_Y,
        local_size_z = LOCAL_WORKGROUP_Z) in;
void main()
{
    u32vec3 idx = gl_GlobalInvocationID.xyz;

    bool oob = idx.x >= RES_X || idx.y >= RES_Y;
    idx.x = min(idx.x, RES_X - 1);
    idx.y = min(idx.y, RES_Y - 1);

    // Lookup our location within the launch grid
    uint32_t batch_idx = idx.z;

    uint32_t pixel_linear_idx =
        batch_idx * RES_Y * RES_X + idx.y * RES_X + idx.x;
    uint32_t rgb_out_offset = 4 * pixel_linear_idx;
    uint32_t depth_out_offset = pixel_linear_idx;

    Camera cam = unpackCamera(batch_idx);

    vec3 ray_origin, ray_dir;
    computeCameraRay(cam, idx.xy, ray_origin, ray_dir);

    rayQueryEXT primary_query;
    bool primary_hit = traceShadeRay(primary_query, batch_idx,
                                     ray_origin, ray_dir, 3);

    if (!primary_hit) {
        setOutput(rgb_out_offset, depth_out_offset, vec3(0, 0, 0), 0);
        return;
    }

    vec2 tri_barys;
    uint32_t tri_idx, material_offset, geo_idx, mesh_offset;
    mat4x3 o2w, w2o;
    getHitParams(primary_query, tri_barys, tri_idx,
                 material_offset, geo_idx, mesh_offset, o2w, w2o);

    Triangle hit_tri = fetchTriangle(tri_idx);
    vec3 world_a = transformPosition(o2w, hit_tri.a.position);
    vec3 world_b = transformPosition(o2w, hit_tri.b.position);
    vec3 world_c = transformPosition(o2w, hit_tri.c.position);
    vec3 world_position =
        interpolatePosition(world_a, world_b, world_c, tri_barys);

    float depth = distance(world_position, cam.origin);

    vec3 rgb = vec3(1, 0, 0);

    if (!oob) {
        setOutput(rgb_out_offset, depth_out_offset, rgb, depth);
    }
}
